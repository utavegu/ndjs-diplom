import { Module } from '@nestjs/common';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { JwtStrategy } from './jwt.strategy';
import { UsersModule } from '../users/users.module';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';

@Module({
  imports: [
    PassportModule,
    // .register({
    //   session: false, // списал из инета, хз что значит. РАЗБЕРИСЬ.
    // }),
    JwtModule.register({
      secret: 'asd79kmr', // TODO: в енв (и узнать откуда берется по нормальному) - побольше абракадабры сюда для безопасности - разный регистр и символы типа _ $ # > ? ^ (если все из них допустимы)
      // По-хорошему секрет берется из некоего AppConfig().jwtSecret
      signOptions: { expiresIn: '120s' }, // В ЕНВ, можно указывать в днях - '7d'
    }),
    UsersModule,
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
})
export class AuthModule {}

/*
1) Довести до ума установку куки и заголовков (всё что тут ниже описано)
2) Вернуть, чтобы токен протухал. Перестал, скорее всего, после того как ты что-то по сессии добавил в мэйне. Либо что-то с пэйлоадом JWT

"Можно задать срок действия кук, а также срок их жизни, после которого куки не будут отправляться. Также можно указать ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту они будут отсылаться."
Expires, Max-Age
"Постоянные cookie (permanent cookies) удаляются не с закрытием клиента, а при наступлении определённой даты (атрибут Expires) или после определённого интервала времени (атрибут Max-Age)."


Что в итоге?

Cookies при правильном использовании являются адекватным и наиболее безопасным на данный момент решением для хранения JWT Access токена и должны следовать следующим правилам:

    Быть установленными для API домена/пути чтобы избежать оверхеда при запросах к статичным файлам (публичным картинкам/стилям/js файлам).
    Иметь флаг Secure (для передачи только по https).
    Иметь флаг httpOnly (для невозможности получения доступа из JavaScript).
    Атрибут SameSite должен быть Strict для защиты от CSRF аттак, запретит передачу Cookie файлов если переход к вашему API был не с установленого в Cookie домена.


На стороне сервера также должно быть настроено:

    Content-Security-Policy – ограничение доверенных доменов для предотвращения возможных XSS атак
    Заголовок X-Frame-Options для защиты от атак типа clickjacking.
    X-XSS-Protection – принудительно включить встроенный механизм защиты браузера от XSS атак.
    X-Content-Type-Options – для защиты от подмены MIME типов.


Соблюдение этих мер вкупе с частой ротацией Access/Refresh токенов должно помочь обеспечить высокий уровень безопасности на сайте.


(это мне памятка)
Как аутентификация/авторизация работает сейчас?
1) При логине, если пользователь найден, а введенный пароль совпадает с тем, который он указывал при регистрации, генерируется JWT-токен
2) Затем он передается в куки на фронтенд

Далее, если пользователь стучится в защищенную ручку, я процесс понимаю так: 
1) JwtStrategy ищет Bearer token в заголовке Authorization, всвязи с тем, как это заявлено в настройках jwtFromRequest
2) Затем, (если он там есть?) переходит к функции validate, которая получает payload токена и ищет пользователя по указанному полю. Если пользователь найден, возвращает его (и вот с этого момента, как мне казалось, user должен прикрепляться к каждому реквест, но по факту это будет происходить, если...:)
3) ...В гарде дергаемой ручки присутствует JwtAuthGuard. Она проверяет наличие юзера и если он есть, возвращает его.
4) И вот дальше уже в этой ручке можно извлекать юзера из реквеста, а так же использовать функции проверки авторизованности.

(еще тут упущен момент роли session из main.ts, но я пока не до конца понял как именно она работает И ЭТОТ НЕДОСТАТОК НАДО УСТРАНИТЬ И РАЗОБРАТЬСЯ, но вроде как будут проблемы с закреплением user-а в request, если там будут некорректные настройки, но я уже не помню и возможно ошибаюсь)
*/
